<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Brodie Gaslam" />


<title>alike</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">
body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.5;
}
#header {
text-align: center;
}
#TOC {
clear: both;

padding: 4px;
width: 100%;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: .5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
h3.subtitle {
margin-top: -23px;
}
pre, code {
background-color: #EEE;
color: #333;
white-space: pre-wrap; 

}
code {font-size: 85%;}
pre {
border: 2px solid #EEE;
overflow: auto;

margin: 5px 0px;
padding: 5px 10px;
}
pre:not([class]) {
color: #353;

}
div.sourceCode pre, div.sourceCode code {
background-color: #FAFAFA;
}
div.sourceCode pre{

}
div.sourceCode + pre,
div.sourceCode + div.diffobj_container {
margin-top: -14px;
}
div.diffobj_container pre{
line-height: 1.3;
}

code {
font-family: Consolas, Monaco, 'Courier New', monospace;
}
p > code, li > code, h1 > code, h2 > code, h3 > code,
h4 > code, h5 > code, h6 > code {
padding: 2px 0px;
line-height: 1;
font-weight: bold;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
padding-bottom: 3px;
font-size: 35px;
line-height: 40px;
border-bottom: 1px solid #999;
}
h2 {
border-bottom: 1px solid #999;
padding-top: 5px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
padding-top: 5px;
font-size: 120%;
}
h4 {

color: #777;
font-size: 105%;
}
h4.author {display: none;}
h4.date {margin-top: -20px;}
h5, h6 {

font-size: 105%;
}
a {
color: #2255dd;
font-weight: bold;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #555; } 
code > span.fl { color: #555; } 
code > span.ch { color: #555; } 
code > span.st { color: #40a070; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">alike</h1>
<h4 class="author">Brodie Gaslam</h4>


<div id="TOC">
<ul>
<li><a href="#what-is-alikeness" id="toc-what-is-alikeness">What is
Alikeness?</a></li>
<li><a href="#declarative-comparison" id="toc-declarative-comparison">Declarative Comparison</a></li>
<li><a href="#object-comparison" id="toc-object-comparison">Object
Comparison</a>
<ul>
<li><a href="#overview" id="toc-overview">Overview</a></li>
<li><a href="#length-comparison" id="toc-length-comparison">Length
Comparison</a></li>
<li><a href="#type-comparison" id="toc-type-comparison">Type
Comparison</a></li>
<li><a href="#recursive-objects" id="toc-recursive-objects">Recursive
Objects</a></li>
<li><a href="#language-objects-formulas-and-functions" id="toc-language-objects-formulas-and-functions">Language Objects,
Formulas, and Functions</a></li>
<li><a href="#s4-and-r5-rc-objects" id="toc-s4-and-r5-rc-objects">S4 and
R5 (RC Objects)</a></li>
<li><a href="#pointer-objects" id="toc-pointer-objects">Pointer
Objects</a></li>
</ul></li>
<li><a href="#attribute-comparison" id="toc-attribute-comparison">Attribute Comparison</a>
<ul>
<li><a href="#normal-attributes" id="toc-normal-attributes">Normal
Attributes</a></li>
<li><a href="#special-attributes" id="toc-special-attributes">Special
Attributes</a></li>
</ul></li>
<li><a href="#modifying-comparison-behavior" id="toc-modifying-comparison-behavior">Modifying Comparison
Behavior</a></li>
<li><a href="#creating-templates" id="toc-creating-templates">Creating
Templates</a>
<ul>
<li><a href="#from-the-ground-up" id="toc-from-the-ground-up">From The
Ground Up</a></li>
<li><a href="#abstracting-existing-structures" id="toc-abstracting-existing-structures">Abstracting Existing
Structures</a></li>
</ul></li>
<li><a href="#performance-considerations" id="toc-performance-considerations">Performance Considerations</a>
<ul>
<li><a href="#sample-timings" id="toc-sample-timings">Sample
Timings</a></li>
<li><a href="#pre-defining-templates" id="toc-pre-defining-templates">Pre-defining Templates</a></li>
</ul></li>
<li><a href="#miscellaneous" id="toc-miscellaneous">Miscellaneous</a>
<ul>
<li><a href="#alike-as-an-s3-generic" id="toc-alike-as-an-s3-generic"><code>alike</code> as an S3
generic</a></li>
</ul></li>
</ul>
</div>

<div id="what-is-alikeness" class="section level2">
<h2>What is Alikeness?</h2>
<p><code>alike</code> is similar to <code>all.equal</code> from base R
except it only compares object structure. As with
<code>all.equal</code>, the first argument (<code>target</code>) must be
matched by the second (<code>current</code>).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(vetr)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">integer</span>(<span class="dv">5</span>), <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)      <span class="co"># different values, but same structure</span></span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">integer</span>(<span class="dv">5</span>), <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)      <span class="co"># wrong size</span></span></code></pre></div>
<pre><code>[1] &quot;`length(1:4)` should be 5 (is 4)&quot;</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">integer</span>(<span class="dv">26</span>), letters) <span class="co"># same size, but different types</span></span></code></pre></div>
<pre><code>[1] &quot;`letters` should be type \&quot;integer-like\&quot; (is \&quot;character\&quot;)&quot;</code></pre>
<p><code>alike</code> only compares structural elements that are defined
in <code>target</code> (a.k.a. the template). This allows “wildcard”
templates. For example, we consider length zero vectors to have
undefined length so those match vectors of any length:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">integer</span>(), <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">integer</span>(), <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">integer</span>(), letters)  <span class="co"># type is still defined and must match</span></span></code></pre></div>
<pre><code>[1] &quot;`letters` should be type \&quot;integer-like\&quot; (is \&quot;character\&quot;)&quot;</code></pre>
<p>Similarly, if a template does not specify an attribute, objects with
any value for that attribute will match:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">list</span>(), <span class="fu">data.frame</span>())  <span class="co"># a data frame is a list with a attributes</span></span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">data.frame</span>(), <span class="fu">list</span>())  <span class="co"># but a list does not have the data.frame attributes</span></span></code></pre></div>
<pre><code>[1] &quot;`list()` should be class \&quot;data.frame\&quot; (is \&quot;list\&quot;)&quot;</code></pre>
<p>As an extension to the wildcard concept, we interpret partially
specified <a href="#Special%20Attributes">core R attributes</a>. Here we
allow any three column integer matrix to match:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>mx.tpl <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">integer</span>(), <span class="at">ncol=</span><span class="dv">3</span>)          <span class="co"># partially specified matrix</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="fu">alike</span>(mx.tpl, <span class="fu">matrix</span>(<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>), <span class="at">nrow=</span><span class="dv">4</span>))  <span class="co"># any number of rows match</span></span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">alike</span>(mx.tpl, <span class="fu">matrix</span>(<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>), <span class="at">nrow=</span><span class="dv">3</span>))  <span class="co"># but column count must match</span></span></code></pre></div>
<pre><code>[1] &quot;`matrix(sample(1:12), nrow = 3)` should have 3 columns (has 4)&quot;</code></pre>
<p>or a data frame of arbitrary number of rows, but same column
structure as <code>iris</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>iris.tpl <span class="ot">&lt;-</span> iris[<span class="dv">0</span>, ]                        <span class="co"># no rows, but structure is defined</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="fu">alike</span>(iris.tpl, iris[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, ])                <span class="co"># any number of rows match</span></span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">alike</span>(iris.tpl, CO2)                         <span class="co"># but column structure must match</span></span></code></pre></div>
<pre><code>[1] &quot;`names(CO2)[1]` should be \&quot;Sepal.Length\&quot; (is \&quot;Plant\&quot;)&quot;</code></pre>
<p>“alikeness” is complex to describe, but should be intuitive to grasp.
We recommend you look <code>example(alike)</code> to get a sense of
“alikeness”. If you want to understand the specifics, read on.</p>
</div>
<div id="declarative-comparison" class="section level2">
<h2>Declarative Comparison</h2>
<p><code>alike</code>’s template based comparison is declarative. You
declare what structure an object is expected to implement, and
<code>vetr</code> infers all the computations required to verify that is
so. This makes is particularly well suited for enforcing structural
requirements for S3 objects. The S4 system does this and more, but S3
objects are still used extensively in R code, and sometimes S4 classes
are not appropriate.</p>
<p>There are several advantages to template based comparisons:</p>
<ul>
<li>Often times it is simpler to define a template than to write out all
the checks to confirm an object conforms to a particular structure.</li>
<li>We can generate the template from a known correct instance of an
object and <a href="#Abstracting-Existing-Objects">abstract away</a> the
elements that are not specific to the prototype (this is particularly
valuable for otherwise complex objects).</li>
<li>We can produce plainish-english interpretations of structural
mismatches since we are dealing with a known limited set of
comparisons.</li>
</ul>
<p>The template concept was inspired by <code>vapply</code>.</p>
</div>
<div id="object-comparison" class="section level2">
<h2>Object Comparison</h2>
<div id="overview" class="section level3">
<h3>Overview</h3>
<p><code>alike</code> compares objects on <a href="#type-comparison">type</a>, <a href="#length-comparison">length</a>, and attributes. Recursive
structures are compared element by element. <a href="#language-objects">Language objects</a> and <a href="#functions">functions</a> are compared specially because the
concept of a value within those is more complex (e.g., is the
<code>+</code> in <code>x + y</code> just a value?).</p>
<p>We will defer discussion of attribute comparison to the <a href="#attribute-comparison">attributes section</a>.</p>
</div>
<div id="length-comparison" class="section level3">
<h3>Length Comparison</h3>
<p>Objects must be the same length to be <code>alike</code>, unless the
template (<code>target</code>) is zero length, in which case the object
may be any length. <a href="#environments">Environments</a> are an
exception: we only require that all the elements present in
<code>target</code> be present in <code>current</code>. Also, note that
calls to <code>(</code> are ignored in <a href="#language-objects">language objects</a>, which may affect length
computation.</p>
</div>
<div id="type-comparison" class="section level3">
<h3>Type Comparison</h3>
<p>Type comparison is done on type (i.e. the <code>typeof</code>) with
some adjustments to better align comparisons to “percieved” types as
opposed to internal storage types.</p>
<div id="numerics-and-integers" class="section level4">
<h4>Numerics and Integers</h4>
<p>We allow integer vectors to be considered numeric, and <a href="#fuzzylen">short</a> integer-like numerics to be treated as
integers:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="dv">1</span><span class="dt">L</span>, <span class="dv">1</span>)     <span class="co"># `1` is not technically integer, but we treat it as such</span></span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="dv">1</span><span class="dt">L</span>, <span class="fl">1.1</span>)   <span class="co"># 1.1 is not integer-like</span></span></code></pre></div>
<pre><code>[1] &quot;`1.1` should be type \&quot;integer-like\&quot; (is \&quot;double\&quot;)&quot;</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fl">1.1</span>, <span class="dv">1</span><span class="dt">L</span>)   <span class="co"># integers can match numerics</span></span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>This feature is designed to simplify checks for integer-like numbers.
The following two expressions are roughly equivalent:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a><span class="fu">stopifnot</span>(<span class="fu">length</span>(x) <span class="sc">==</span> <span class="dv">1</span><span class="dt">L</span> <span class="sc">&amp;&amp;</span> (<span class="fu">is.integer</span>(x) <span class="sc">||</span> <span class="fu">is.numeric</span>(x) <span class="sc">&amp;&amp;</span> <span class="fu">floor</span>(x) <span class="sc">==</span> x))</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a><span class="fu">stopifnot</span>(<span class="fu">alike</span>(<span class="fu">integer</span>(<span class="dv">1</span><span class="dt">L</span>), x))</span></code></pre></div>
<p><a name="fuzzylen"></a>Note that we only check numerics of length
&lt;= 100 for integerness to avoid full scans on large vectors. We
expect that the primary source of these integer-like numerics is hand
input vectors (e.g. <code>c(1, 2, 3)</code>), so hopefully this
compromise is not too limiting. You can modify the threshold length for
this treatment via the <code>fuzzy.int.max.len</code> parameter to the
<code>settings</code> objects (see <code>?vetr_settings</code>).</p>
</div>
<div id="functions" class="section level4">
<h4>Functions</h4>
<p>Closures, builtins, and specials are all treated as a single type,
even though internally they are stored as different types.</p>
</div>
</div>
<div id="recursive-objects" class="section level3">
<h3>Recursive Objects</h3>
<p><code>alike</code> will recurse through lists (and by extension data
frames), pairlists, expressions, and environments and will check
pairwise alikeness between the corresponding elements of the
<code>target</code> and <code>current</code> objects.</p>
<p><a name="environments"></a>Environments have slightly different
comparison rules in two respects:</p>
<ul>
<li>only the elements present in the template are checked, so
<code>current</code> may have additional items</li>
<li>if the template is the global environment, then <code>current</code>
must be too (this is because the global environment is often littered
with many objects, and explicitly comparing it to another environment
could be computationally expensive)</li>
</ul>
<p><code>NULL</code> elements within templates in recursive objects are
considered undefined and as such act like wildcards:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="do">## two NULLs match two length list</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">list</span>(<span class="cn">NULL</span>, <span class="cn">NULL</span>), <span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, letters))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="do">## but not three length list</span></span>
<span id="cb34-2"><a href="#cb34-2" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">list</span>(<span class="cn">NULL</span>, <span class="cn">NULL</span>), <span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, letters, iris))</span></code></pre></div>
<pre><code>[1] &quot;`length(list(1:10, letters, iris))` should be 2 (is 3)&quot;</code></pre>
<p>Note that top level <code>NULL</code>s do not act as wildcards:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="cn">NULL</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>)                   <span class="co"># NULL only matches NULL</span></span></code></pre></div>
<pre><code>[1] &quot;`1:10` should be `NULL` (is \&quot;integer\&quot;)&quot;</code></pre>
<p>Treating <code>NULL</code> inconsistently depending on whether it is
nested or not is a compromise designed to make <code>alike</code> a
better fit for argument validation because arguments that are
<code>NULL</code> by default are fairly common.</p>
<p><code>alike</code> will check for self-referential loops in nested
environments and prevent infinite recursion. If you somehow introduce a
self-referential structure in a template without using environments then
<code>alike</code> will get stuck in an infinite recursion loop.</p>
<p>We are currently considering adding new comparison modes for lists
that would allow for checks more similar to environments (see <a href="https://github.com/brodieG/vetr/issues/29">#29</a>).</p>
</div>
<div id="language-objects-formulas-and-functions" class="section level3">
<h3>Language Objects, Formulas, and Functions</h3>
<p>Alikeness for these types of objects is a little harder to define. We
have settled on somewhat arbitrary semantics, though hopefully they are
intuitive. These may change in the future as we gain experience using
<code>alike</code> with these types of objects. This is particularly
true of functions.</p>
<p>Language objects are also compared recursively, but alikeness has a
slightly different meaning for them:</p>
<div id="language-objects" class="section level4">
<h4>Language Objects</h4>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">quote</span>(<span class="fu">sum</span>(a, b)), <span class="fu">quote</span>(<span class="fu">sum</span>(x, y)))   <span class="co"># calls are consistent</span></span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">quote</span>(<span class="fu">sum</span>(a, b)), <span class="fu">quote</span>(<span class="fu">sum</span>(x, x)))   <span class="co"># calls are inconsistent</span></span></code></pre></div>
<pre><code>[1] &quot;`quote(sum(x, x))[[3]]` should not be `x`&quot;</code></pre>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">quote</span>(<span class="fu">mean</span>(a, b)), <span class="fu">quote</span>(<span class="fu">sum</span>(x, y)))  <span class="co"># functions are different</span></span></code></pre></div>
<pre><code>[1] &quot;`quote(sum(x, y))[[1]]` should be a call to `mean` (is a call to `sum`)&quot;</code></pre>
<p>Since variables can contain anything we do not require them to match
directly across calls. In the examples above the second call fails
because the template defines different variables for each argument, but
the <code>current</code> object uses the same variable twice. The third
call fails because the functions are different and as such the calls are
fundamentally different.</p>
<p>If a function is defined in the calling frame, <code>alike</code>
will <code>match.call</code> it prior to testing alikeness:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a>fun <span class="ot">&lt;-</span> <span class="cf">function</span>(a, b, c) <span class="cn">NULL</span></span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">quote</span>(<span class="fu">fun</span>(p, q, p)), <span class="fu">quote</span>(<span class="fu">fun</span>(y, x, x)))</span></code></pre></div>
<pre><code>[1] &quot;`quote(fun(y, x, x))[[4]]` should be `y` (is `x`)&quot;</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="co"># `match.call` re-orders arguments</span></span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">quote</span>(<span class="fu">fun</span>(p, q, p)), <span class="fu">quote</span>(<span class="fu">fun</span>(<span class="at">b=</span>y, x, x)))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>Constants match any constants, but keep in mind that expressions like
<code>1:10</code> or <code>c(1, 2, 3)</code> are calls to <code>:</code>
and <code>c</code> respectively, not constants in the context of
language objects.</p>
<p><code>NULL</code> is a wild card in calls as well:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="fu">str</span>(one.arg.tpl <span class="ot">&lt;-</span> <span class="fu">as.call</span>(<span class="fu">list</span>(<span class="cn">NULL</span>, <span class="cn">NULL</span>)))</span></code></pre></div>
<pre><code> language NULL(NULL)</code></pre>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="fu">alike</span>(one.arg.tpl, <span class="fu">quote</span>(<span class="fu">log</span>(<span class="dv">10</span>)))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="fu">alike</span>(one.arg.tpl, <span class="fu">quote</span>(<span class="fu">sd</span>(<span class="fu">runif</span>(<span class="dv">20</span>))))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="fu">alike</span>(one.arg.tpl, <span class="fu">quote</span>(<span class="fu">log</span>(<span class="dv">10</span>, <span class="dv">10</span>)))</span></code></pre></div>
<pre><code>[1] &quot;`quote(log(10, 10))` should have 1 arguments (has 2)&quot;</code></pre>
<p>Calls to <code>(</code> are ignored when comparing calls since
parentheses are redundant in call trees because the tree structure
encodes operation precedence independent of operator precedence.</p>
<p>We concede that the rules for “alikeness” of language objects are
arbitrary, but hope the outcomes of those rules is generally intuitive.
Unfortunately value and structure are somewhat intertwined for language
objects so we must impose our own view of what is value and what is
structure.</p>
</div>
<div id="formulas" class="section level4">
<h4>Formulas</h4>
<p>Formulas are treated like calls, except that constants must
match:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="fu">alike</span>(y <span class="sc">~</span> x <span class="sc">^</span> <span class="dv">2</span>, a <span class="sc">~</span> b <span class="sc">^</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="fu">alike</span>(y <span class="sc">~</span> x <span class="sc">^</span> <span class="dv">2</span>, a <span class="sc">~</span> b <span class="sc">^</span> <span class="dv">3</span>)</span></code></pre></div>
<pre><code>[1] &quot;`(a ~ b^3)[[3]][[3]]` should have identical constant values&quot;</code></pre>
</div>
<div id="functions-1" class="section level4">
<h4>Functions</h4>
<p>Functions are <code>alike</code> if the signature of the
<code>current</code> function can reasonably be interpreted as a valid
method for the <code>target</code> function.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="fu">alike</span>(print, print.default)   <span class="co"># print can be the generic for print.default</span></span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="fu">alike</span>(print.default, print)   <span class="co"># but not vice versa</span></span></code></pre></div>
<pre><code>[1] &quot;`print` should have argument `digits` after argument `x`&quot;</code></pre>
<p>A method of a generic must have all arguments present in the generic,
with the same default values if those are defined. If the generic
contains <code>...</code> then the method may have additional arguments,
but must also contain <code>...</code>.</p>
<p>Potential changes / improvements for function comparison are being
considered in <a href="https://github.com/brodieG/vetr/issues/35">#35</a>.</p>
</div>
</div>
<div id="s4-and-r5-rc-objects" class="section level3">
<h3>S4 and R5 (RC Objects)</h3>
<p>S4 and RC objects are considered alike if <code>current</code>
inherits from <code>class(target)</code>. Since these objects embed
structural information in their definitions <code>alike</code> relies on
class alone to establish alikeness.</p>
</div>
<div id="pointer-objects" class="section level3">
<h3>Pointer Objects</h3>
<p>Objects of the following types are actually references to specific
memory locations:</p>
<ul>
<li>External Pointers</li>
<li>Weak References</li>
<li>Byte codes</li>
</ul>
<p>These are typically attached as attributes to other objects that
contain the information required to establish alikeness
(e.g. <code>data.table</code>, byte-compiled functions), so we only
check their type.</p>
</div>
</div>
<div id="attribute-comparison" class="section level2">
<h2>Attribute Comparison</h2>
<div id="normal-attributes" class="section level3">
<h3>Normal Attributes</h3>
<p>Much of the structure of an object is determined by attributes.
<code>alike</code> recursively compares object attributes and requires
them to be <code>alike</code>, unless the attribute is a <a href="#special-attributes">special attribute</a> or an environment.
Environments within attributes in the template must be matched by an
environment, but nothing is checked about the environments to avoid
expensive computations on objects that commonly include environments in
their attributes (e.g. formulas); note this is different than the
treatment of environments as actual objects.</p>
<p>Only attributes present in the template object are checked:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">structure</span>(<span class="fu">logical</span>(<span class="dv">1</span><span class="dt">L</span>), <span class="at">a=</span><span class="fu">integer</span>(<span class="dv">3</span><span class="dt">L</span>)), <span class="fu">structure</span>(<span class="cn">TRUE</span>, <span class="at">a=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">b=</span>letters))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">structure</span>(<span class="cn">TRUE</span>, <span class="at">a=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">b=</span>letters), <span class="fu">structure</span>(<span class="fu">logical</span>(<span class="dv">1</span><span class="dt">L</span>), <span class="at">a=</span><span class="fu">integer</span>(<span class="dv">3</span><span class="dt">L</span>)))</span></code></pre></div>
<pre><code>[1] &quot;`structure(logical(1L), a = integer(3L))` should have attribute \&quot;b\&quot;&quot;</code></pre>
<p>Attributes present in <code>current</code> but missing in
<code>target</code> may be anything at all.</p>
</div>
<div id="special-attributes" class="section level3">
<h3>Special Attributes</h3>
<div id="overview-1" class="section level4">
<h4>Overview</h4>
<p>The special attributes are <code>names</code>,
<code>row.names</code>, <code>dim</code>, <code>dimnames</code>,
<code>class</code>, <code>tsp</code>, and <code>levels</code>. These
attributes are discussed in sections <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Attributes">2.2
and 2.3 of the R Language Definition</a>, and have well defined and
consistently applied semantics in R. Since the semantics of these
attributes are well known, we are able to define “alikeness” for them in
a more granular way than we can for arbitrary attributes.</p>
<p>We also consider <code>srcref</code> to be a special attribute. This
attribute is not checked.</p>
</div>
<div id="row.names-and-names" class="section level4">
<h4>row.names and names</h4>
<p>If present in <code>target</code>, then must be matched exactly by
the corresponding attribute in <code>current</code>, except that:</p>
<ul>
<li>zero length <code>target</code>
<code>names</code>/<code>row.names</code>
(i.e. <code>character(0L)</code>) will match any character
<code>names</code>/<code>row.names</code></li>
<li>a zero character <em>element</em> (i.e. <code>&quot;&quot;</code>) in a
<code>target</code> <code>names</code>/<code>row.names</code> character
vector will allow any value to match at the corresponding position of
the <code>current</code> <code>names</code>/<code>row.names</code>
vector</li>
</ul>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">setNames</span>(<span class="fu">integer</span>(), <span class="fu">character</span>()), <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span></code></pre></div>
<pre><code>[1] &quot;`1:3` should have attribute \&quot;names\&quot;&quot;</code></pre>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">setNames</span>(<span class="fu">integer</span>(), <span class="fu">character</span>()), <span class="fu">c</span>(<span class="at">a=</span><span class="dv">1</span>, <span class="at">b=</span><span class="dv">2</span>, <span class="at">c=</span><span class="dv">3</span>))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb72"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb72-1"><a href="#cb72-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">setNames</span>(<span class="fu">integer</span>(<span class="dv">3</span>), <span class="fu">c</span>(<span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;Z&quot;</span>)), <span class="fu">c</span>(<span class="at">a=</span><span class="dv">1</span>, <span class="at">b=</span><span class="dv">2</span>, <span class="at">c=</span><span class="dv">3</span>))</span></code></pre></div>
<pre><code>[1] &quot;`names(c(a = 1, b = 2, c = 3))[3]` should be \&quot;Z\&quot; (is \&quot;c\&quot;)&quot;</code></pre>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a><span class="fu">alike</span>(<span class="fu">setNames</span>(<span class="fu">integer</span>(<span class="dv">3</span>), <span class="fu">c</span>(<span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;Z&quot;</span>)), <span class="fu">c</span>(<span class="at">a=</span><span class="dv">1</span>, <span class="at">b=</span><span class="dv">2</span>, <span class="at">Z=</span><span class="dv">3</span>))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
</div>
<div id="dim" class="section level4">
<h4>dim</h4>
<p><code>dim</code> attributes must be identical between
<code>target</code> and <code>current</code>, except that if a value of
the <code>dim</code> <em>vector</em> is zero in <code>target</code> then
the corresponding value in <code>current</code> can be any value. This
is how comparisons like the following succeed:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a>mx.tpl <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">integer</span>(), <span class="at">ncol=</span><span class="dv">3</span>)                <span class="co"># partially specified matrix</span></span>
<span id="cb76-2"><a href="#cb76-2" tabindex="-1"></a><span class="fu">alike</span>(mx.tpl, <span class="fu">matrix</span>(<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>), <span class="at">nrow=</span><span class="dv">4</span>))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a><span class="fu">alike</span>(mx.tpl, <span class="fu">matrix</span>(<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">12</span>), <span class="at">nrow=</span><span class="dv">3</span>))        <span class="co"># wrong number of columns</span></span></code></pre></div>
<pre><code>[1] &quot;`matrix(sample(1:12), nrow = 3)` should have 3 columns (has 4)&quot;</code></pre>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a><span class="fu">str</span>(mx.tpl)    <span class="co"># notice 0 for 1st dimension</span></span></code></pre></div>
<pre><code> int[0 , 1:3] </code></pre>
</div>
<div id="dimnames" class="section level4">
<h4>dimnames</h4>
<p>Must also be identical, except that if the <code>target</code> value
of the <code>dimnames</code> list for a particular dimension is
<code>NULL</code>, then the corresponding <code>dimnames</code> value in
<code>current</code> may be anything. As with <code>names</code>, zero
character <code>dimname</code> element elements match any name.</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a>mx.tpl <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">integer</span>(), <span class="at">ncol=</span><span class="dv">3</span>, <span class="at">dimnames=</span><span class="fu">list</span>(<span class="at">row.id=</span><span class="cn">NULL</span>, <span class="fu">c</span>(<span class="st">&quot;R&quot;</span>, <span class="st">&quot;G&quot;</span>, <span class="st">&quot;&quot;</span>)))</span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>mx.cur <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">sample</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">255</span>, <span class="dv">12</span>), <span class="at">ncol=</span><span class="dv">3</span>, <span class="at">dimnames=</span><span class="fu">list</span>(<span class="at">row.id=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, <span class="at">rgb=</span><span class="fu">c</span>(<span class="st">&quot;R&quot;</span>, <span class="st">&quot;G&quot;</span>, <span class="st">&quot;Blue&quot;</span>)))</span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a>mx.cur2 <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">sample</span>(<span class="dv">0</span><span class="sc">:</span><span class="dv">255</span>, <span class="dv">12</span>), <span class="at">ncol=</span><span class="dv">3</span>, <span class="at">dimnames=</span><span class="fu">list</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>, <span class="fu">c</span>(<span class="st">&quot;R&quot;</span>, <span class="st">&quot;G&quot;</span>, <span class="st">&quot;b&quot;</span>)))</span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a></span>
<span id="cb82-5"><a href="#cb82-5" tabindex="-1"></a><span class="fu">alike</span>(mx.tpl, mx.cur)</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb84"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb84-1"><a href="#cb84-1" tabindex="-1"></a><span class="fu">alike</span>(mx.tpl, mx.cur2)</span></code></pre></div>
<pre><code>[1] &quot;`dimnames(mx.cur2)` should have attribute \&quot;names\&quot;&quot;</code></pre>
<p>Note that <code>dimnames</code> can have a <code>names</code>
attribute. This <code>names</code> attributed is treated as described in
<a href="#row.names-and-names">row.names and names</a>.</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a><span class="fu">names</span>(<span class="fu">dimnames</span>(mx.tpl))</span></code></pre></div>
<pre><code>[1] &quot;row.id&quot; &quot;&quot;      </code></pre>
</div>
<div id="class" class="section level4">
<h4>class</h4>
<p>S3 objects are considered alike if the <code>current</code> class
inherits from the <code>target</code> class. Note that “inheritance”
here is used in a stricter context than in the typical S3
application:</p>
<ul>
<li>Every class present in <code>target</code> must be present in
<code>current</code></li>
<li>The overlapping classes must be in the same order</li>
<li>The last class in <code>current</code> must be the same as the last
class in <code>target</code></li>
</ul>
<p>To illustrate:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a>tpl <span class="ot">&lt;-</span> <span class="fu">structure</span>(<span class="cn">TRUE</span>, <span class="at">class=</span><span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))</span>
<span id="cb88-2"><a href="#cb88-2" tabindex="-1"></a>cur <span class="ot">&lt;-</span> <span class="fu">structure</span>(<span class="cn">TRUE</span>, <span class="at">class=</span><span class="fu">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))</span>
<span id="cb88-3"><a href="#cb88-3" tabindex="-1"></a>cur2 <span class="ot">&lt;-</span> <span class="fu">structure</span>(<span class="cn">TRUE</span>, <span class="at">class=</span><span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;x&quot;</span>))</span>
<span id="cb88-4"><a href="#cb88-4" tabindex="-1"></a></span>
<span id="cb88-5"><a href="#cb88-5" tabindex="-1"></a><span class="fu">alike</span>(tpl, cur)</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a><span class="fu">alike</span>(tpl, cur2)</span></code></pre></div>
<pre><code>[1] &quot;`class(cur2)[2]` should be \&quot;a\&quot; (is \&quot;b\&quot;)&quot;</code></pre>
</div>
<div id="tsp" class="section level4">
<h4>tsp</h4>
<p>The <code>tsp</code> attribute of <code>ts</code> objects behaves
similarly to the <a href="#dim"><code>dim</code> attribute</a>. Any
component (i.e. start, end, frequency) that is set to zero will act as a
wild card. Other components must be identical. It is illegal to set
<code>tsp</code> components to zero throught the standard R interface,
but you may use <code>abstract</code> as a work-around.</p>
</div>
<div id="levels" class="section level4">
<h4>levels</h4>
<p>Levels are compared like <a href="#row.names-and-names">row.names and
names</a>.</p>
</div>
<div id="srcref" class="section level4">
<h4>srcref</h4>
<p>This attribute is completely ignored.</p>
</div>
<div id="normal-attributes-that-happen-to-have-special-names" class="section level4">
<h4>Normal Attributes that Happen To Have Special Names</h4>
<p>If an object contains one of the special attributes, but the
attribute value is inconsistent with the standard definition of the
attribute, <code>alike</code> will silently treat that attribute as any
other normal attribute.</p>
</div>
</div>
</div>
<div id="modifying-comparison-behavior" class="section level2">
<h2>Modifying Comparison Behavior</h2>
<p>You can use the <code>settings</code> parameter to <code>alike</code>
to modify comparison behavior. See <code>?vetr_settings</code> for
details.</p>
</div>
<div id="creating-templates" class="section level2">
<h2>Creating Templates</h2>
<div id="from-the-ground-up" class="section level3">
<h3>From The Ground Up</h3>
<p>You can always create your own templates by manually building R
structures:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" tabindex="-1"></a>int.scalar <span class="ot">&lt;-</span> <span class="fu">integer</span>(<span class="dv">1</span><span class="dt">L</span>)</span>
<span id="cb92-2"><a href="#cb92-2" tabindex="-1"></a>int.mat.<span class="fl">2.</span>by<span class="fl">.4</span> <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">integer</span>(), <span class="dv">2</span>, <span class="dv">4</span>)</span>
<span id="cb92-3"><a href="#cb92-3" tabindex="-1"></a><span class="co"># A df without column names</span></span>
<span id="cb92-4"><a href="#cb92-4" tabindex="-1"></a>df.chr.num.num <span class="ot">&lt;-</span> <span class="fu">structure</span>(</span>
<span id="cb92-5"><a href="#cb92-5" tabindex="-1"></a>  <span class="fu">list</span>(<span class="fu">character</span>(), <span class="fu">numeric</span>(), <span class="fu">numeric</span>()), <span class="at">class=</span><span class="st">&quot;data.frame&quot;</span></span>
<span id="cb92-6"><a href="#cb92-6" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="abstracting-existing-structures" class="section level3">
<h3>Abstracting Existing Structures</h3>
<p>Alternatively, you can start with a known structure, and abstract
away the instance-specific details. For example, suppose we are sending
sample collectors out on the field to record information about iris
flowers:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" tabindex="-1"></a>iris.tpl <span class="ot">&lt;-</span> iris[<span class="dv">0</span>, ]</span>
<span id="cb93-2"><a href="#cb93-2" tabindex="-1"></a><span class="fu">alike</span>(iris.tpl, iris.sample<span class="fl">.1</span>)  <span class="co"># make sure they submit data correctly</span></span></code></pre></div>
<p>Or equivalently:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb94-1"><a href="#cb94-1" tabindex="-1"></a>iris.tpl <span class="ot">&lt;-</span> <span class="fu">abstract</span>(iris)</span></code></pre></div>
<p><code>abstract</code> is an S3 generic defined by <code>alike</code>
along with methods for common objects. <code>abstract</code> primarily
sets the <code>length</code> of atomic vectors to zero:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" tabindex="-1"></a><span class="fu">abstract</span>(<span class="fu">list</span>(<span class="fu">c</span>(<span class="at">a=</span><span class="dv">1</span>, <span class="at">b=</span><span class="dv">2</span>, <span class="at">c=</span><span class="dv">3</span>), letters))</span></code></pre></div>
<pre><code>[[1]]
named numeric(0)

[[2]]
character(0)</code></pre>
<p>and also abstracts the <code>dim</code>, <code>dimnames</code>, and
<code>tsp</code> attributes if present. Other attributes are left
untouched unless a specific <code>abstract</code> method exists for a
particular object that also modifies attributes. One example of such a
method is <code>abstract.lm</code>, and it does some minor tweaking to
the base abstractions to allow us to match models produced by
<code>lm</code>:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" tabindex="-1"></a>df.dummy <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">x=</span><span class="fu">runif</span>(<span class="dv">3</span>), <span class="at">y=</span><span class="fu">runif</span>(<span class="dv">3</span>), <span class="at">z=</span><span class="fu">runif</span>(<span class="dv">3</span>))</span>
<span id="cb97-2"><a href="#cb97-2" tabindex="-1"></a>mdl.tpl <span class="ot">&lt;-</span> <span class="fu">abstract</span>(<span class="fu">lm</span>(y <span class="sc">~</span> x <span class="sc">+</span> z, df.dummy))</span>
<span id="cb97-3"><a href="#cb97-3" tabindex="-1"></a><span class="co"># TRUE, expecting bi-variate model</span></span>
<span id="cb97-4"><a href="#cb97-4" tabindex="-1"></a><span class="fu">alike</span>(mdl.tpl, <span class="fu">lm</span>(Sepal.Length <span class="sc">~</span> Sepal.Width <span class="sc">+</span> Petal.Width, iris))</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<div class="sourceCode" id="cb99"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb99-1"><a href="#cb99-1" tabindex="-1"></a><span class="fu">alike</span>(mdl.tpl, <span class="fu">lm</span>(Sepal.Length <span class="sc">~</span> Sepal.Width, iris))</span></code></pre></div>
<pre><code>[1] &quot;`lm(Sepal.Length ~ Sepal.Width, iris)$terms[[3]]` should be a call to `+` (is \&quot;symbol\&quot;)&quot;</code></pre>
<p>The error message is telling us that at index <code>&quot;terms&quot;</code>
(i.e. <code>lm(Sepal.Length ~ Sepal.Width, iris)$terms</code>)
<code>alike</code> was expecting a call to <code>+</code> instead of a
symbol (i.e <code>Sepal.Width + &lt;somevar&gt;</code> instead of
<code>Sepal.Width</code>). The message could certainly be more eloquent,
but with a little context it should provide enough information to figure
out the problem.</p>
</div>
</div>
<div id="performance-considerations" class="section level2">
<h2>Performance Considerations</h2>
<div id="sample-timings" class="section level3">
<h3>Sample Timings</h3>
<p>We have gone to great lengths to make <code>alike</code> fast so that
it can be included in other functions without concerns for what
overhead:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb101-1"><a href="#cb101-1" tabindex="-1"></a>type_and_len <span class="ot">&lt;-</span> <span class="cf">function</span>(a, b)</span>
<span id="cb101-2"><a href="#cb101-2" tabindex="-1"></a>  <span class="fu">typeof</span>(a) <span class="sc">==</span> <span class="fu">typeof</span>(b) <span class="sc">&amp;&amp;</span> <span class="fu">length</span>(a) <span class="sc">==</span> <span class="fu">length</span>(b)  <span class="co"># for reference</span></span>
<span id="cb101-3"><a href="#cb101-3" tabindex="-1"></a></span>
<span id="cb101-4"><a href="#cb101-4" tabindex="-1"></a><span class="fu">bench_mark</span>(<span class="at">times=</span><span class="fl">1e4</span>,</span>
<span id="cb101-5"><a href="#cb101-5" tabindex="-1"></a>  <span class="fu">identical</span>(rivers, rivers),</span>
<span id="cb101-6"><a href="#cb101-6" tabindex="-1"></a>  <span class="fu">alike</span>(rivers, rivers),</span>
<span id="cb101-7"><a href="#cb101-7" tabindex="-1"></a>  <span class="fu">type_and_len</span>(rivers, rivers)</span>
<span id="cb101-8"><a href="#cb101-8" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>Mean eval time from 10000 iterations, in microseconds:
  identical(rivers, rivers)     ~  0.5
  alike(rivers, rivers)         ~  2.2
  type_and_len(rivers, rivers)  ~  1.5</code></pre>
<p>While <code>alike</code> is slower than <code>identical</code> and
the comparable bare bones R function, it is competitive with a bare
bones R function that checks types and length. As objects grow more
complex, <code>identical</code> will obviously pull ahead, though
<code>alike</code> should be sufficiently fast for most
applications:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" tabindex="-1"></a><span class="fu">bench_mark</span>(<span class="at">times=</span><span class="fl">1e4</span>,</span>
<span id="cb103-2"><a href="#cb103-2" tabindex="-1"></a>  <span class="fu">identical</span>(mtcars, mtcars),</span>
<span id="cb103-3"><a href="#cb103-3" tabindex="-1"></a>  <span class="fu">alike</span>(mtcars, mtcars)</span>
<span id="cb103-4"><a href="#cb103-4" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>Mean eval time from 10000 iterations, in microseconds:
  identical(mtcars, mtcars)  ~  0.4
  alike(mtcars, mtcars)      ~  9.1</code></pre>
<p>In the above example, we are comparing the data frames, their
attributes, and the 11 columns individually.</p>
<p>Keep in mind that the complexity of the <code>alike</code> comparison
is driven by the complexity of the template, not the object we are
checking, so we can always manage the expense of the <code>alike</code>
evaluation.</p>
<p>Comparisons that succeed will be substantially faster than
comparisons that fail as the construction of error messages is
non-trivial and we have prioritized optimization in the success
case.</p>
<p>Language object comparison is relatively slow. We intend to optimize
this some day.</p>
<p>Templates with large numbers of attributes (e.g. &gt; 25) may scale
non-linearly. We intend to optimize this some day, though in our
experience objects with that many attributes are rare (note having
multiple objects each with a handful attributes nested in recursive
structures is not a problem).</p>
<p>Large objects will be slower to evaluate. Let us revisit the
<code>lm</code> example, though this time we compare our template to
itself to ensure that the comparisons succeed for <code>alike</code>,
<code>all.equal</code>, and <code>identical</code>:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" tabindex="-1"></a>mdl.tpl <span class="ot">&lt;-</span> <span class="fu">abstract</span>(<span class="fu">lm</span>(y <span class="sc">~</span> x <span class="sc">+</span> z, <span class="fu">data.frame</span>(<span class="at">x=</span><span class="fu">runif</span>(<span class="dv">3</span>), <span class="at">y=</span><span class="fu">runif</span>(<span class="dv">3</span>), <span class="at">z=</span><span class="fu">runif</span>(<span class="dv">3</span>))))</span>
<span id="cb105-2"><a href="#cb105-2" tabindex="-1"></a><span class="co"># compare mdl.tpl to itself to ensure success in all three scenarios</span></span>
<span id="cb105-3"><a href="#cb105-3" tabindex="-1"></a><span class="fu">bench_mark</span>(</span>
<span id="cb105-4"><a href="#cb105-4" tabindex="-1"></a>  <span class="fu">alike</span>(mdl.tpl, mdl.tpl),</span>
<span id="cb105-5"><a href="#cb105-5" tabindex="-1"></a>  <span class="fu">all.equal</span>(mdl.tpl, mdl.tpl),   <span class="co"># for reference</span></span>
<span id="cb105-6"><a href="#cb105-6" tabindex="-1"></a>  <span class="fu">identical</span>(mdl.tpl, mdl.tpl)</span>
<span id="cb105-7"><a href="#cb105-7" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>Mean eval time from 1000 iterations, in microseconds:
  alike(mdl.tpl, mdl.tpl)      ~   116
  all.equal(mdl.tpl, mdl.tpl)  ~  1413
  identical(mdl.tpl, mdl.tpl)  ~     1</code></pre>
<p>Even with template as large as <code>lm</code> results (check
<code>str(mdl.tpl)</code>) we can evaluate <code>alike</code> thousands
of times before the overhead becomes noticeable.</p>
</div>
<div id="pre-defining-templates" class="section level3">
<h3>Pre-defining Templates</h3>
<p>Some fairly innocuous R expressions carry substantial overhead.
Consider:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" tabindex="-1"></a>df.tpl <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">a=</span><span class="fu">integer</span>(), <span class="at">b=</span><span class="fu">numeric</span>())</span>
<span id="cb107-2"><a href="#cb107-2" tabindex="-1"></a>df.cur <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">a=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">b=</span><span class="dv">1</span><span class="sc">:</span><span class="dv">10</span> <span class="sc">+</span> .<span class="dv">1</span>)</span>
<span id="cb107-3"><a href="#cb107-3" tabindex="-1"></a></span>
<span id="cb107-4"><a href="#cb107-4" tabindex="-1"></a><span class="fu">bench_mark</span>(</span>
<span id="cb107-5"><a href="#cb107-5" tabindex="-1"></a>  <span class="fu">alike</span>(df.tpl, df.cur),</span>
<span id="cb107-6"><a href="#cb107-6" tabindex="-1"></a>  <span class="fu">alike</span>(<span class="fu">data.frame</span>(<span class="fu">integer</span>(), <span class="fu">numeric</span>()), df.cur)</span>
<span id="cb107-7"><a href="#cb107-7" tabindex="-1"></a>)</span></code></pre></div>
<pre><code>Mean eval time from 1000 iterations, in microseconds:
  alike(df.tpl, df.cur)                     ~    5
  alike(data.frame(integer(), numeric())..  ~  258</code></pre>
<p><code>data.frame</code> is a particularly slow constructor, but in
general you are best served by defining your templates (including calls
to <code>abstract</code>) outside of your function so they are created
on package load rather than every time your function is called.</p>
</div>
</div>
<div id="miscellaneous" class="section level2">
<h2>Miscellaneous</h2>
<div id="alike-as-an-s3-generic" class="section level3">
<h3><code>alike</code> as an S3 generic</h3>
<p><code>alike</code> is not currently an S3 generic, but will likely
one in the future provided we can create an implementation with and
acceptable performance profile.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
